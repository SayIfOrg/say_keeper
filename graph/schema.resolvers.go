package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.30

import (
	"context"
	"encoding/json"
	"github.com/SayIfOrg/say_keeper/dal"
	"github.com/SayIfOrg/say_keeper/graph/dataloader"
	"log"
	"strconv"

	"github.com/SayIfOrg/say_keeper/commenting"
	"github.com/SayIfOrg/say_keeper/graph/gmodel"
	"github.com/SayIfOrg/say_keeper/models"
	"github.com/SayIfOrg/say_keeper/utils"
)

// ReplyTo is the resolver for the replyTo field.
func (r *commentResolver) ReplyTo(ctx context.Context, obj *gmodel.Comment) (*gmodel.Comment, error) {
	if obj.ReplyToID == nil {
		return nil, nil
	}
	return dataloader.For(ctx).GetComment(ctx, *obj.ReplyToID)
}

// Replies is the resolver for the replies field.
func (r *commentResolver) Replies(ctx context.Context, obj *gmodel.Comment) ([]*gmodel.Comment, error) {
	var replies []models.Comment
	referenceID := utils.RStringToUint(&obj.ID)
	dbc := r.DB.WithContext(ctx).Where(&models.Comment{ReplyToId: referenceID}).Find(&replies)
	if dbc.Error != nil {
		return nil, dbc.Error
	}
	var gReplies []*gmodel.Comment
	for _, reply := range replies {
		gReply := gmodel.FromDBComment(&reply)
		gReplies = append(gReplies, gReply)
	}
	return gReplies, nil
}

// CreateComment is the resolver for the CreateComment field.
func (r *mutationResolver) CreateComment(ctx context.Context, comment gmodel.NewComment) (*gmodel.Comment, error) {
	userID, err := strconv.Atoi(comment.UserID)
	if err != nil {
		return nil, err
	}
	newComment, err := dal.CreateComment(
		&ctx,
		r.DB,
		uint(userID),
		utils.RStringToUint(comment.ReplyToID),
		comment.Content,
		commenting.WebAgent,
		"",
	)
	if err != nil {
		return nil, err
	}
	gNewContent := gmodel.FromDBComment(newComment)
	// publish the posted comment to be used by subscription (or by ...)
	jsonBytes, err := json.Marshal(gNewContent)
	if err != nil {
		panic(err)
	}
	err = commenting.PublishComment(r.RDB, ctx, jsonBytes)
	if err != nil {
		// TODO proper handle this case
		log.Println("error in publishing the comment", err)
	}
	return gNewContent, nil
}

// Users is the resolver for the users field.
func (r *queryResolver) Users(ctx context.Context) ([]*gmodel.User, error) {
	var users []*models.User
	dbc := r.DB.WithContext(ctx).Find(&users)
	if dbc.Error != nil {
		return nil, dbc.Error
	}
	var gUsers []*gmodel.User
	for _, user := range users {
		gUser := gmodel.FromDBUser(user)
		gUsers = append(gUsers, gUser)
	}
	return gUsers, nil
}

// Comments is the resolver for the comments field.
func (r *queryResolver) Comments(ctx context.Context) ([]*gmodel.Comment, error) {
	var comments []*models.Comment
	dbr := r.DB.WithContext(ctx).Limit(100).Find(&comments)
	if dbr.Error != nil {
		return nil, dbr.Error
	}
	var gComments []*gmodel.Comment
	for _, comment := range comments {
		gComment := gmodel.FromDBComment(comment)
		gComments = append(gComments, gComment)
	}
	return gComments, nil
}

// LatestComment is the resolver for the latestComment field.
func (r *subscriptionResolver) LatestComment(ctx context.Context) (<-chan *gmodel.Comment, error) {
	commentAddedChan := make(chan *gmodel.Comment)
	r.Subs.Mu.Lock()
	r.Subs.Subs = append(r.Subs.Subs, commentAddedChan)
	r.Subs.Mu.Unlock()
	return commentAddedChan, nil
}

// Comment returns CommentResolver implementation.
func (r *Resolver) Comment() CommentResolver { return &commentResolver{r} }

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

// Subscription returns SubscriptionResolver implementation.
func (r *Resolver) Subscription() SubscriptionResolver { return &subscriptionResolver{r} }

type commentResolver struct{ *Resolver }
type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
type subscriptionResolver struct{ *Resolver }
