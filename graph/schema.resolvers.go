package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.24

import (
	"context"
	"fmt"
	"math/rand"
	"strconv"
	"time"

	"github.com/SayIfOrg/say_keeper/graph/gmodel"
	"github.com/SayIfOrg/say_keeper/models"
	"github.com/SayIfOrg/say_keeper/utils"
)

// ReplyTo is the resolver for the replyTo field.
func (r *commentResolver) ReplyTo(_ context.Context, obj *gmodel.Comment) (*gmodel.Comment, error) {
	if obj.ReplyToID == nil {
		return nil, nil
	}
	ReplyToID, err := strconv.ParseUint(*obj.ReplyToID, 10, 0)
	if err != nil {
		return nil, err
	}
	var relatedComment = models.Comment{}
	dbc := r.DB.First(&relatedComment, uint(ReplyToID))
	if dbc.Error != nil {
		return nil, dbc.Error
	}
	gRelatedComment := &gmodel.Comment{
		ID:        strconv.Itoa(int(relatedComment.ID)),
		UserID:    strconv.Itoa(int(relatedComment.UserID)),
		ReplyToID: utils.RUintToString(relatedComment.ReplyToId),
		Content:   relatedComment.Content,
		Agent:     relatedComment.Agent,
	}
	return gRelatedComment, err
}

// Replies is the resolver for the replies field.
func (r *commentResolver) Replies(_ context.Context, obj *gmodel.Comment) ([]*gmodel.Comment, error) {
	var replies []models.Comment
	referenceID := utils.RStringToUint(&obj.ID)
	dbc := r.DB.Where(&models.Comment{ReplyToId: referenceID}).Find(&replies)
	if dbc.Error != nil {
		return nil, dbc.Error
	}
	var gReplies []*gmodel.Comment
	for _, reply := range replies {
		gReply := &gmodel.Comment{
			ID:        strconv.Itoa(int(reply.ID)),
			UserID:    strconv.Itoa(int(reply.UserID)),
			ReplyToID: utils.RUintToString(reply.ReplyToId),
			Content:   reply.Content,
			Agent:     reply.Agent,
		}
		gReplies = append(gReplies, gReply)
	}
	return gReplies, nil
}

// CreateComment is the resolver for the CreateComment field.
func (r *mutationResolver) CreateComment(_ context.Context, comment gmodel.NewComment) (*gmodel.Comment, error) {
	userID, _ := strconv.Atoi(comment.UserID)
	newComment := &models.Comment{
		UserID:    uint(userID),
		ReplyToId: utils.RStringToUint(comment.ReplyToID),
		Content:   comment.Content,
		Agent:     comment.Agent,
	}
	dbr := r.DB.Create(newComment)
	if dbr.Error != nil {
		return nil, dbr.Error
	}
	gNewContent := &gmodel.Comment{
		ID:        strconv.Itoa(int(newComment.ID)),
		UserID:    strconv.Itoa(int(newComment.UserID)),
		ReplyToID: utils.RUintToString(newComment.ReplyToId),
		Content:   comment.Content,
		Agent:     comment.Agent}
	return gNewContent, nil
}

// Users is the resolver for the users field.
func (r *queryResolver) Users(_ context.Context) ([]*gmodel.User, error) {
	var users []*models.User
	dbc := r.DB.Find(&users)
	if dbc.Error != nil {
		return nil, dbc.Error
	}
	var gUsers []*gmodel.User
	for _, user := range users {
		gUser := &gmodel.User{
			ID:   strconv.Itoa(int(user.ID)),
			Name: user.Name,
		}
		gUsers = append(gUsers, gUser)
	}
	return gUsers, nil
}

// Comments is the resolver for the comments field.
func (r *queryResolver) Comments(_ context.Context) ([]*gmodel.Comment, error) {
	var comments []*models.Comment
	dbr := r.DB.Find(&comments)
	if dbr.Error != nil {
		return nil, dbr.Error
	}
	var gComments []*gmodel.Comment
	for _, comment := range comments {
		gComment := &gmodel.Comment{
			ID:        strconv.Itoa(int(comment.ID)),
			UserID:    strconv.Itoa(int(comment.UserID)),
			ReplyToID: utils.RUintToString(comment.ReplyToId),
			Content:   comment.Content,
			Agent:     comment.Agent,
		}
		gComments = append(gComments, gComment)
	}
	return gComments, nil
}

// LatestComment is the resolver for the latestComment field.
func (r *subscriptionResolver) LatestComment(_ context.Context) (<-chan *gmodel.Comment, error) {
	// This is dummy for now

	ch := make(chan *gmodel.Comment)

	const letters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"
	rand.Seed(time.Now().UnixNano())

	// TODO handle channels in a central place outside of `schema.resolvers.go`
	go func() {
		for {
			time.Sleep(5 * time.Second)
			fmt.Println("ping")

			n := rand.Intn(100) + 1
			b := make([]byte, n)
			for i := range b {
				randIndex := rand.Intn(len(letters))
				b[i] = letters[randIndex]
			}

			currentTime := time.Now()
			t := &gmodel.Comment{
				ID:        strconv.Itoa(int(currentTime.Unix())),
				UserID:    "5",
				ReplyToID: nil,
				//ReplyTo:   nil,
				//Replies:   nil,
				Content: string(b),
				Agent:   "telegram",
			}

			// The channel may have gotten closed due to the client disconnecting.
			// To not have our Goroutine block or panic, we do the send in a select block.
			// This will jump to the default case if the channel is closed.
			select {
			case ch <- t: // This is the actual send.
				// Our message went through, do nothing
			default: // This is run when our send does not work.
				fmt.Println("Channel closed.")
				// You can handle any deregistration of the channel here.
				return // We'll just return ending the routine.
			}
		}
	}()

	// We return the channel and no error.
	return ch, nil
}

// Comment returns CommentResolver implementation.
func (r *Resolver) Comment() CommentResolver { return &commentResolver{r} }

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

// Subscription returns SubscriptionResolver implementation.
func (r *Resolver) Subscription() SubscriptionResolver { return &subscriptionResolver{r} }

type commentResolver struct{ *Resolver }
type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
type subscriptionResolver struct{ *Resolver }
