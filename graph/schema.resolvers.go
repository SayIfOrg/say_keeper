package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.24

import (
	"context"
	"strconv"

	"github.com/SayIfOrg/say_keeper/graph/gmodel"
	"github.com/SayIfOrg/say_keeper/models"
	"github.com/SayIfOrg/say_keeper/utils"
)

// ReplyTo is the resolver for the replyTo field.
func (r *commentResolver) ReplyTo(_ context.Context, obj *gmodel.Comment) (*gmodel.Comment, error) {
	if obj.ReplyToID == nil {
		return nil, nil
	}
	ReplyToID, err := strconv.ParseUint(*obj.ReplyToID, 10, 0)
	if err != nil {
		return nil, err
	}
	var relatedComment = models.Comment{}
	dbc := r.DB.First(&relatedComment, uint(ReplyToID))
	if dbc.Error != nil {
		return nil, dbc.Error
	}
	gRelatedComment := &gmodel.Comment{
		ID:        strconv.Itoa(int(relatedComment.ID)),
		UserID:    strconv.Itoa(int(relatedComment.UserID)),
		ReplyToID: utils.RUintToString(relatedComment.ReplyToId),
		Content:   relatedComment.Content,
		Agent:     relatedComment.Agent,
	}
	return gRelatedComment, err
}

// Replies is the resolver for the replies field.
func (r *commentResolver) Replies(_ context.Context, obj *gmodel.Comment) ([]*gmodel.Comment, error) {
	var replies []models.Comment
	referenceID := utils.RStringToUint(&obj.ID)
	dbc := r.DB.Where(&models.Comment{ReplyToId: referenceID}).Find(&replies)
	if dbc.Error != nil {
		return nil, dbc.Error
	}
	var gReplies []*gmodel.Comment
	for _, reply := range replies {
		gReply := &gmodel.Comment{
			ID:        strconv.Itoa(int(reply.ID)),
			UserID:    strconv.Itoa(int(reply.UserID)),
			ReplyToID: utils.RUintToString(reply.ReplyToId),
			Content:   reply.Content,
			Agent:     reply.Agent,
		}
		gReplies = append(gReplies, gReply)
	}
	return gReplies, nil
}

// CreateComment is the resolver for the CreateComment field.
func (r *mutationResolver) CreateComment(_ context.Context, comment gmodel.NewComment) (*gmodel.Comment, error) {
	userID, _ := strconv.Atoi(comment.UserID)
	newComment := &models.Comment{
		UserID:    uint(userID),
		ReplyToId: utils.RStringToUint(comment.ReplyToID),
		Content:   comment.Content,
		Agent:     comment.Agent,
	}
	dbr := r.DB.Create(newComment)
	if dbr.Error != nil {
		return nil, dbr.Error
	}
	gNewContent := &gmodel.Comment{
		ID:        strconv.Itoa(int(newComment.ID)),
		UserID:    strconv.Itoa(int(newComment.UserID)),
		ReplyToID: utils.RUintToString(newComment.ReplyToId),
		Content:   comment.Content,
		Agent:     comment.Agent}
	return gNewContent, nil
}

// Users is the resolver for the users field.
func (r *queryResolver) Users(_ context.Context) ([]*gmodel.User, error) {
	var users []*models.User
	dbc := r.DB.Find(&users)
	if dbc.Error != nil {
		return nil, dbc.Error
	}
	var gUsers []*gmodel.User
	for _, user := range users {
		gUser := &gmodel.User{
			ID:   strconv.Itoa(int(user.ID)),
			Name: user.Name,
		}
		gUsers = append(gUsers, gUser)
	}
	return gUsers, nil
}

// Comments is the resolver for the comments field.
func (r *queryResolver) Comments(_ context.Context) ([]*gmodel.Comment, error) {
	var comments []*models.Comment
	dbr := r.DB.Find(&comments)
	if dbr.Error != nil {
		return nil, dbr.Error
	}
	var gComments []*gmodel.Comment
	for _, comment := range comments {
		gComment := &gmodel.Comment{
			ID:        strconv.Itoa(int(comment.ID)),
			UserID:    strconv.Itoa(int(comment.UserID)),
			ReplyToID: utils.RUintToString(comment.ReplyToId),
			Content:   comment.Content,
			Agent:     comment.Agent,
		}
		gComments = append(gComments, gComment)
	}
	return gComments, nil
}

// Comment returns CommentResolver implementation.
func (r *Resolver) Comment() CommentResolver { return &commentResolver{r} }

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type commentResolver struct{ *Resolver }
type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
